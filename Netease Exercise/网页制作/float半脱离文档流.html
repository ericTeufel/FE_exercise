<!DOCTYPE html>
<html lang="en">
<head>
  <title></title>
  <meta charset="utf-8">
  <style type="text/css">
    body{margin: 0;padding: 0;width: 1100px;border: 1px dotted red;margin: 0 auto;line-height: 1.6;}
    .float{
      float: left;
      background-color: yellow;
      width: 100px;
      height: 100px;
      margin:10px;
      line-height: 100px;
      text-align: center;
    }
    .content{
      border: 1px dashed blue;margin: 2px;
    }
    .clearfix::after{content: '.';display: block;clear: both;
    height: 0;visibility: hidden;overflow: hidden;
  }
  .clearfix{zoom:1;}//兼容ie低版本
</style>
</head>
<body>
  <div class="clearfix content">
    <div class="float">1</div>
    <div class="float">2</div>
    <div ><p>实例化obj对象有三步：

      　　1. 创建obj对象：obj=new Object();

      　　2. 将obj的内部__proto__指向构造他的函数A的prototype，同时，obj.constructor===A.prototype.constructor(这个是永远成立的，即使A.prototype不再指向原来
    </p>
  </div>
</div>
<div class="content"><p>　的A原型，也就是说：类的实例对象的constructor属性永远指向"构造函数"的prototype.constructor)，从而使得obj.constructor.prototype指向A.prototype（obj.constructor.prototype===A.prototype，当A.prototype改变时则不成立，下文有遇到）。obj.constructor.prototype与的内部_proto_是两码事，实例化对象时用的是_proto_，obj是没有prototype属性的，但是有内部的__proto__，通过__proto__来取得原型链上的原型属性和原型方法，FireFox公开了__proto__，可以在FireFox中alert（obj.__proto__）；　3. 将obj作为this去调用构造函数A，从而设置成员（即对象属性和对象方法）并初始化。

  　　当这3步完成，这个obj对象就与构造函数A再无联系，这个时候即使构造函数A再加任何成员，都不再影响已经实例化的obj对象了。此时，obj对象具有了x属性，同时具有了构造函数A的原型对象的所有成员，当然，此时该原型对象是没有成员的。

  　　原型对象初始是空的，也就是没有一个成员（即原型属性和原型方法）。可以通过如下方法验证原型对象具有多少成员。</p>
</div>
</body>
</html>
